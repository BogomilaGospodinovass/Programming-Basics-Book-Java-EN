# Chapter 9.1. Problems for Champions – Part I

In this chapter, we will offer the reader a few **more difficult tasks** that aim to develop **algorithmic skills** and acquire **programming techniques** to solve tasks with higher complexity.

## More Complex Problems on the Studied Material

We will solve together several programming problems that cover the material studied in the book, but more difficult than the usual problems of the entrance exams at SoftUni. If you want to become a **champion on the basics of programming**, we recommend training to solve such complex tasks to make it easy for you to take exams.


## Problem: Crossing Sequences

We have two sequences:
   - **a sequence of Tribonacci** (by analogy with the Fibonacci sequence), where each number is **the sum of the previous three** (with given three numbers)
   - a sequence generated by a **numerical spiral** defined by looping like a spiral (right, bottom, left, top, right, bottom, left, top, etc.) of a matrix of numbers starting from its center with a given starting number and incremental step, by storing the current numbers in the sequence each time we make a turn

Write a program that finds the first number that appears **in both sequences defined in the aforementioned way**.

### Example

Let **the Tribonacci sequence** start with **1**, **2** and **3**. This means that **the first sequence** will contain the numbers 1, 2, 3, 6, 11, 20, 37, 68, 125, 230, 423, 778, 1431, 2632, 4841, 8904, 16377, 30122, 55403, 101902, and so on.

At the same time, let the **numbers in the spiral** begin with **5** and the spiral increases by **2** at each step.

<img src="assets/chapter-9-1-images/01.Crossing-sequences-01.png" style="float: right; height: 250px;" />

Then **the second sequence** will contain the numbers 5, 7, 9, 13, 17, 23, 29, 37 and so on. We see that **37** is the first number to be found in the Tribonacci sequence and in the spiral one, and that is the desired solution to the problem.

### Input Data

Input data should be read from the console.
   * On the first three lines of the input we will read **three integers**, representing **the first three numbers** in the Tribonacci sequence, positive non-zero numbers, sorted in ascending order.
   * On the next two lines of the input we will read **two integers** representing **the first number** and **the step** for each cell of the matrix for the spiral of numbers. The numbers representing the spiral are positive non-zero numbers.

Input data will always be valid and will always be in the format described. There is no need to check.

### Output Data

The result should be printed on the console.

On the single line of the output, we must print **the smallest number that occurs in both sequences**. If there is no number **in the range** [**1 … 1 000 000**], which can be found in both sequences, print "**No**".

### Constraints

* All numbers in the input will be in the range [**1 … 1 000 000**].
* Allowed program time: 0.3 seconds.
* Allowed memory: 16 MB.

### Sample Input and Output

| Input | Output  | Input | Output | Input | Output |
|-------|---------|-------|--------|-------|--------|
|1<br>2<br>3<br>5<br>2<br>|37|13<br>25<br>99<br>5<br>2|13|99<br>99<br>99<br>2<br>2|No|


| Input | Output  | Input | Output|
| ------ | ------- | ------ | ----|
|1<br>1<br>1<br>1<br>1|1|1<br>4<br>7<br>23<br>3|23|

### Hints and Guidelines

The problem seems quite complicated, so we will break it into simpler sub-problems.

#### Processing the Input

The first step in solving the problem is to read and process the input. Input data consists of **5 integers**: **3** for the Tribonacci sequence and **2** for the numerical spiral.

![](assets/chapter-9-1-images/01.Crossing-sequences-02.png)

Once we have the input data, we need to think about how we will generate the numbers in the two sequences.

#### Generating Tribonacci Sequence

For the Tribonacci sequence we will always **collect the previous three values** and then move the values of those numbers (the three previous ones) one position in the sequence, i.e. the value of the first one must accept the value of the second one, and so on. When we are done with the number, we will store its value in **an array**. Since the problem description states that the numbers in the sequences do not exceed 1,000,000, we can stop generating this range at exactly 1,000,000.

![](assets/chapter-9-1-images/01.Crossing-sequences-03.png)

#### Generating Numerical Spiral

We need to think of **a relation** between numbers in the numerical spiral so we can easily generate every next number without having to look at matrices and loop through them. If we carefully look at the picture from the description, we will notice that **every 2 "turns" in the spiral, the numbers we skip are increased by 1**, i.e. from *5 to 7* and from *7 to 9*, not a single number is skipped, but we directly **add with the step** of the sequence. From *9 to 13* and from *13 to 17* we skip a number, i.e. we add the step twice. From *17 to 23* and from *23 to 29* we skip two numbers, i.e. we add the step three times and so on.

Thus, we see that for the first two we have **`the last number + 1 * the step`**, the next two we add with the **`2 * the step`** and so on. 
Every time we want to get to the next number of the spiral, we will have to make such calculations.

![](assets/chapter-9-1-images/01.Crossing-sequences-04.png)

What we have to take care of is **for each two numbers, our multiplier** (let's call it "coefficient") **must increase by 1** (**` spiralStepMul++`**), which can be achieved with a simple check (**`spiralCount % 2 == 0`**). The whole code from the generation of the spiral in **an array** is given below.

![](assets/chapter-9-1-images/01.Crossing-sequences-05.png)

#### Finding Common Number for the Sequences

Once we have generated the numbers in both sequences, we can proceed to unite them and build the final solution. How will it look? For **each of the numbers** in the first sequence (starting from the smaller one) we will check if it exists in the other one. The first number that meets this criterion will be **the answer** to the problem.

We will do a **linear** search in the second array, and we will leave the more curious participants to optimize it using the technique called **binary search** because the second array is generated in sorted form, i.e. it meets the requirement to apply this type of search. The code for finding our solution will look like this:

![](assets/chapter-9-1-images/01.Crossing-sequences-06.png)

The previous solution to the problem uses arrays to store the values. Arrays are not needed to solve the problem. There is an **alternative solution** that generates the numbers and works directly with them instead of keeping them in an array. On **every step** we can check whether **the numbers in the two sequences match**. If this is the case, we will print the number on the console and terminate the execution of our program. Otherwise, we will see the current number of **which sequence is the smaller one and we will generate the next one where we are "lagging"**. The idea is that **we will generate numbers from the sequence that is "behind"** until we skip the current number of the other sequence and then vice versa, and if we find a match in the meantime, we will terminate the execution.

![](assets/chapter-9-1-images/01.Crossing-sequences-07.png)

### Testing in the Judge System

Test your solution here: [https://judge.softuni.bg/Contests/Practice/Index/663#0](https://judge.softuni.bg/Contests/Practice/Index/663#0).


## Problem: Magic Dates

**Date** is given in a "**dd-mm-yyyy**" format, e.g. 17-04-2018. We calculate **the weight of that date** by taking all of its digits, multiplying each digit with the others after it, and finally summing up all the results obtained. In our case, we have 8 digits: **17032007**, so the weight is **`1*7 + 1*0 + 1*3 + 1*2 + 1*0 + 1*0 + 1*7`** **+** **`7*0 + 7*3 + 7*2 + 7*0 + 7*0 + 7*7`** **+** **`0*3 + 0*2 + 0*0 + 0*0 + 0*7`** **+** **`3*2 + 3*0 + 3*0 + 3*7`** **+** **`2*0 + 2*0 + 2*7`** **+** **`0*0 + 0*7`** **+** **`0*7`** = **144**.

Our task is to write a program that finds all the **magical dates between two specific years (inclusively) corresponding to given weight**. Dates must be printed in ascending order (by date) in the format "**dd-mm-yyyy**". We will only use the valid dates in the traditional calendar (the leap years have 29 days in February).

### Input Data

Input data should be read from the console. It consists of 3 lines:

   * The first line contains an integer: **start year**.
   * The second line contains an integer: **end year**.
   * The third line contains an integer: **the search weight** for the dates.

Input data will always be valid and will always be in the format described. No need to check.

### Изходни данни

Резултатът трябва да бъде принтиран на конзолата, като последователни дати във **формат "дд-мм-гггг"**, подредени по дата в нарастващ ред. Всеки низ трябва да е на отделен ред. В случай, че няма съществуващи магически дати, да се принтира "**No**".
### Ограничения

* Началната и крайната година са цели числа в периода [**1900-2100**].
* Магическото тегло е цяло число в диапазона [**1 … 1000**].
* Позволено работно време за програмата: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход      | Вход | Изход      |
|------|------------|------|------------|
|2007<br>2007<br>144|17-03-2007<br>13-07-2007<br>31-07-2007|2003<br>2004<br>1500<br>|No|

| Вход | Изход      | Вход | Изход      |
|------|------------|------|------------|
|2012<br>2014<br>80|09-01-2013<br>17-01-2013<br>23-03-2013<br>11-07-2013<br>01-09-2013<br>10-09-2013<br>09-10-2013<br>17-10-2013<br>07-11-2013<br>24-11-2013<br>14-12-2013<br>23-11-2014<br>13-12-2014<br>31-12-2014|2011<br>2012<br>14<br>|01-01-2011<br>10-01-2011<br>01-10-2011<br>10-10-2011|

### Насоки и подсказки

Започваме от входните данни. В случая имаме **3 цели числа**, които трябва да се прочетат от конзолата, като с това се изчерпва въвеждането и обработването на входа за задачата.

Разполагайки с началната и крайната година, е хубаво да разберем как ще минем през всяка дата, без да се объркваме от това колко дена има в месеца и дали е високосна година и т.н.

#### Обхождане на всички дати

За обхождането ще се възползваме от функционалността, която ни дава **`LocalDate`** класът в **C#**. Ще си дефинираме **променлива за началната дата**, което можем да направим, използвайки конструктора, който приема година, месец и ден. Знаем, че годината е началната година, която сме прочели от конзолата, а месеца и деня трябва да са съответно януари и 1-ви. При Java "конструкторът" на **`LocalDate`** приема като първи аргумент годината, като втори аргумент месеца и като трети аргумент деня от месеца.

![](assets/chapter-9-1-images/02.Magic-dates-01.png)

След като имаме началната дата, искаме да направим **цикъл, който се изпълнява, докато не превишим крайната година** (или докато не преминем 31 декември в крайната година, ако сравняваме целите дати), като на всяка стъпка увеличава с по 1 ден.

За да увеличаваме с 1 ден при всяко завъртане, ще използваме метод от **`LocalDate` - `plusDays(…)`**, чрез който ще добавяме по един ден към текущата дата. Методът ще се грижи вместо нас кога трябва да прескочи в следващия месец, колко дни има даден месец и всичко около високосните години.

![](assets/chapter-9-1-images/02.Magic-dates-02.png)

***Внимание***: тъй като методът **`LocalDate.plusDays(…)`** връща "новата" дата, е важно да имаме присвояване на резултата, а не само извикване на метода! 

В крайна сметка нашият цикъл може да изглежда по следния начин:

![](assets/chapter-9-1-images/02.Magic-dates-03.png)

***Забележка***: може да постигнем същия резултат с **`for` цикъл**, инициализацията на датата отива в първата част на **`for`**, условието се запазва, а стъпката е увеличаването с 1 ден.

#### Пресмятане на теглото

Всяка дата се състои от точно **8 символа (цифри)** - **2 за деня** (**`d1`**, **`d2`**), **2 за месеца** (**`d3`**, **`d4`**) и **4 за годината** (**`d5`** до **`d8`**). Това означава, че всеки път ще имаме едно и също пресмятане и може да се възползваме от това, за **да дефинираме формулата статично** (т.е. да не обикаляме с цикли, реферирайки различни цифри от датата, а да изпишем цялата формула). За да успеем да я изпишем, ще ни трябват **всички цифри от датата** в отделни променливи, за да направим всички нужни умножения. Използвайки операциите деление и взимане на остатък върху отделните компоненти на датата, чрез методите **`getDayOfMonth()`**, **`getMonthValue()`** и **`getYear()`**, можем да извлечем всяка цифра.

![](assets/chapter-9-1-images/02.Magic-dates-04.png)

Нека обясним и един от по-интересните редове тук. Нека вземе за пример взимането на втората цифра от годината (**`d6`**). При нея делим годината на 100 и взимаме остатък от 10. Какво постигаме така? Първо с деленето на 100 отстраняваме последните 2 цифри от годината (пример: **`2018 / 100 = 20`**). С остатъка от деление на 10 взимаме последната цифра на полученото число (**`20 % 10 = 0`**) и така получаваме 0, което е втората цифра на 2018.

Остава да направим изчислението, което ще ни даде магическото тегло на дадена дата. За да **не изписваме всички умножения**, както е показано в примера, ще приложим просто групиране. Това, което трябва да направим, е да умножим всяка цифра с тези, които са след нея. Вместо да изписваме **`d1 * d2 + d1 * d3 + … + d1 * d8`**, може да съкратим този израз до **`d1 * (d2 + d3 + … + d8)`**, следвайки математическите правила за групиране, когато имаме умножение и събиране. Прилагайки същото опростяване за останалите умножения, получаваме следната формула: 

![](assets/chapter-9-1-images/02.Magic-dates-05.png)

#### Отпечатване на изхода

След като имаме пресметнато теглото на дадена дата, трябва **да проверим дали съвпада с търсеното от нас магическо тегло**, за да знаем, дали трябва да се принтира или не. Проверката може да се направи със стандартен **`if`** блок, като трябва да се внимава при принтирането датата да е в правилния формат. За да форматираме дата в желания за нас вид, ще използваме **`DateTimeFormatter`** класа.

![](assets/chapter-9-1-images/02.Magic-dates-06.png)

***Внимание***: тъй като обхождаме датите от началната година към крайната, те винаги ще бъдат подредени във възходящ ред, както е по условие.

И накрая, ако не сме намерили нито една дата, отговаряща на условията, ще имаме **`false`** стойност във **`found`** променливата и ще можем да отпечатаме **`No`**.

![](assets/chapter-9-1-images/02.Magic-dates-07.png)

### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/663#1](https://judge.softuni.bg/Contests/Practice/Index/663#1).


## Задача: пет специални букви

Дадени са две числа: **начало** и **край**. Напишете програма, която **генерира всички комбинации от 5 букви**, всяка измежду множеството **`{'a', 'b', 'c', 'd', 'e'}`**, така че теглото на тези 5 букви да е число в интервала **`[начало … край]`**, включително. Принтирайте ги по азбучен ред, на един ред, разделени с интервал.

**Теглото на една буква** се изчислява по следния начин:

```java 
weight('а') = 5;
weight('b') = -12;
weight('c') = 47;
weight('d') = 7;
weight('e') = -32;
```

**Теглото на редицата** от букви **`c1, c2, …, cn`** е изчислено, като се премахват всички букви, които се повтарят (от дясно наляво), и след това се пресметне формулата:

```java 
weight(c1c2…cn) = 1 * weight(c1) + 2 * weight(c2) + … + n * weight(cn)
```

**Например**, теглото на **`bcddc`** се изчислява по следния начин: 

Първо **премахваме повтарящите се букви** и получаваме **`bcd`**. След това прилагаме формулата: **`1 * weight('b') + 2 * weight('c') + 3 * weight('d') = 1 * (-12) + 2 * 47 + 3 * 7 = 103`**.

**Друг пример**: **`weight("cadae") = weight("cade") = 1 * 47 + 2 * 5 + 3 * 7 + 4 * (-32) = -50`**.

### Входни данни

Входните данни се четат от конзолата. Състоят се от две числа:
* Числото за **начало**.
* Числото за **край**.

Входните данни винаги ще бъдат валидни и винаги ще са в описания формат. Няма нужда да се проверяват.

### Изходни данни

Резултатът трябва да бъде принтиран на конзолата като поредица от низове, **подредени по азбучен ред**. Всеки низ трябва да бъде отделен от следващия с едно разстояние. Ако теглото на нито един от 5 буквените низове не съществува в зададения интервал, принтирайте "**No**".

### Ограничения

* Числата за **начало** и **край** да бъдат цели числа в диапазона [**-10000  … 10000**].
* Позволено работно време за програмата: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход       | Коментар             |
| ------ | ------------- | ---------------------- |
|40<br>42|bcead bdcea |weight("bcead") = 41<br>weight("bdcea") = 40|

| Вход | Изход         |
| ------ |---------------|
|-1<br>1| bcdea cebda eaaad eaada eaadd eaade eaaed eadaa eadad eadae eadda eaddd eadde eadea eaded eadee eaead eaeda eaedd eaede eaeed eeaad eeada eeadd eeade eeaed eeead|

| Вход | Изход      |
| ------ |------------|
|200<br>300|baadc babdc badac badbc badca badcb badcc badcd baddc bbadc bbdac bdaac bdabc bdaca bdacb bdacc bdacd bdadc bdbac bddac beadc bedac eabdc ebadc ebdac edbac|

| Вход | Изход  |
| ------ | -------- |
|300<br>400| No|

### Насоки и подсказки

Като всяка задача, започваме решението с **прочитане и обработване на входните данни**. В случая имаме **две цели числа**, които можем да обработим с комбинация от методите **`Integer.parseInt(…)`** и **`Scanner.nextLine()`**.

![](/assets/chapter-9-1-images/03.Five-special-letters-01.png)

В задачата имаме няколко основни момента - **генерирането на всички комбинации** с дължина 5 включващи 5-те дадени букви, **премахването на повтарящите се букви** и **пресмятането на теглото** за дадена вече опростена дума. Отговорът ще се състои от всяка дума, чието тегло е в дадения интервал **`[firstNumber, secondNumber]`**.

#### Генериране на всички комбинации

За да генерираме **всички комбинации с дължина 1** използвайки 5 символа, бихме използвали **цикъл от 0..4**, като всяко число от цикъла ще искаме да отговаря на един символ. За да генерираме **всички комбинации с дължина 2** използвайки 5 символа (т.е. "aa", "ab", "ac", …, "ba", …), бихме направили **два вложени цикъла, всеки обхождащ цифрите от 0 до 4**, като отново ще направим, така че всяка цифра да отговаря на конкретен символ. Тази стъпка ще повторим 5 пъти, така че накрая да имаме 5 вложени цикъла с индекси **`i1`**, **`i2`**, **`i3`**, **`i4`** и **`i5`**.

![](assets/chapter-9-1-images/03.Five-special-letters-02.png)

Имайки всички 5-цифрени комбинации, трябва да намерим начин да "превърнем" петте цифри в дума с буквите от '**a**' до '**e**'. Един от начините да направим това е, като си **предефинираме прост стринг съдържащ буквите**, които имаме

![](assets/chapter-9-1-images/03.Five-special-letters-03.png)

и **за всяка цифра взимаме буквата от конкретната позиция**. По този начин числото **00000** ще стане **"aaaaa"**, числото **02423** ще стане **"acecd"**. Можем да направим стринга от 5 букви по следния начин.

![](assets/chapter-9-1-images/03.Five-special-letters-04.png)

***Друг начин***: можем да преобразуваме цифрите до букви, използвайки подредбата им в **ASCII таблицата**. Изразът **`'а' + i`** ще ни даде резултата **`'a'`** при **`i = 0`**, **`'b'`** при **`i = 1`**, **`'c'`** при **`i = 2`** и т.н.

Така вече имаме генерирани всички 5-буквени комбинации и можем да продължим със следващата част от задачата.

***Внимание***: тъй като сме подбрали **`pattern`**, съобразен с азбучната подредба на буквите и циклите се въртят по подходящ начин, алгоритъмът ще генерира думите в азбучен ред и няма нужда от допълнително сортиране преди извеждане.

#### Премахването на повтарящи се букви

След като имаме вече готовия низ, трябва да премахнем всички повтарящи се символи. Ще направим тази операция, като **добавяме буквите от ляво надясно в нов низ и всеки път преди да добавим буква ще проверяваме дали вече я има** - ако я има ще я пропускаме, а ако я няма ще я добавяме. За начало ще добавим първата буква към началния стринг.

![](assets/chapter-9-1-images/03.Five-special-letters-05.png)

След това ще направим същото и с останалите 4, проверявайки всеки път дали ги има със следното условие и метода **`.indexOf(…)`**. Това може да стане с цикъл по **`fullWord`** (оставяме това на читателя за упражнение), а може да стане и по мързеливия начин с copy-paste.

![](assets/chapter-9-1-images/03.Five-special-letters-06.png)

Методът **`.indexOf(…)`** връща **индекса на конкретния елемент, ако бъде намерен или **`-1`**, ако елементът не бъде намерен**. Следователно всеки път, когато получим **`-1`**, ще означава, че все още нямаме тази буква в новия низ с уникални букви и можем да я добавим, а ако получим стойност различна от **`-1`**, ще означава, че вече имаме буквата и няма да я добавяме.

#### Пресмятане на теглото
 
Пресмятането на теглото е просто **обхождане на уникалната дума** (**`word`**), получена в миналата стъпка, като за всяка буква трябва да вземем теглото ѝ и да я умножим по позицията. За всяка буква в обхождането трябва да пресметнем с каква стойност ще умножим позицията ѝ, например чрез използването на **`switch`** конструкция.

![](assets/chapter-9-1-images/03.Five-special-letters-07.png)

След като имаме стойността на дадената буква, следва да я **умножим по позицията ѝ**. Тъй като индексите в стринга се различават с 1 от реалните позиции, т.е. индекс 0 е позиция 1, индекс 1 е позиция 2 и т.н., ще добавим 1 към индексите.

![](assets/chapter-9-1-images/03.Five-special-letters-08.png)

Всички получени междинни резултати трябва да бъдат добавени към **обща сума за всяка една буква от 5-буквената комбинация**.

#### Оформяне на изхода

Дали дадена дума трябва да се принтира, се определя по нейната тежест. Трябва ни условие, което да определи дали **текущата тежест е в интервала** [**начало … край**], подаден ни на входа в началото на програмата. Ако това е така, принтираме **пълната** дума (**`fullWord`**).

**Внимавайте** да не принтирате думата от уникални букви. Тя ни бе необходима само за пресмятане на тежестта!

Думите са **разделени с интервал** и ще ги натрупваме в междинна променлива **`result`**, която е дефинирана като празен низ в началото.

![](assets/chapter-9-1-images/03.Five-special-letters-09.png)

#### Финални щрихи

Условието е изпълнено **с изключение случаите, в които нямаме нито една дума в подадения интервал**. За да разберем дали сме намерили такава дума, можем просто да проверим дали низът **`result`** има началната си стойност (а именно празен низ), ако е така - отпечатваме **`No`**, иначе печатаме целия низ без последния интервал (използвайки метода **`.trim()`**).

![](assets/chapter-9-1-images/03.Five-special-letters-10.png)

### Тестване в Judge системата

Тествайте решението си тук: [https://judge.softuni.bg/Contests/Practice/Index/663#2](https://judge.softuni.bg/Contests/Practice/Index/663#2).
